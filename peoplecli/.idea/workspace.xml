<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="aef1bef0-1ae4-4a98-9cf4-dad6d86e150b" name="Default Changelist" comment="">
      <change beforePath="$PROJECT_DIR$/../people-service/src/peoplesort/base.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/src/peoplesort/base.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/src/peoplesort/handler.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/src/peoplesort/handler.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/src/peoplesort/http.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/src/peoplesort/http.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/src/peoplesort/output.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/src/peoplesort/output.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/src/peoplesort/persistence.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/src/peoplesort/persistence.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/src/peoplesort/sorting.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/src/peoplesort/sorting.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/src/peoplesort/upload.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/src/peoplesort/upload.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/target/classes/META-INF/maven/peoplesort/peoplesort/pom.properties" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/target/classes/META-INF/maven/peoplesort/peoplesort/pom.properties" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/target/repl-port" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/target/repl-port" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/target/stale/leiningen.core.classpath.extract-native-dependencies" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/target/stale/leiningen.core.classpath.extract-native-dependencies" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/test/peoplesort/handler_test.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/test/peoplesort/handler_test.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/test/peoplesort/sorting_test.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/test/peoplesort/sorting_test.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/test/peoplesort/test_utility.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/test/peoplesort/test_utility.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../people-service/test/peoplesort/upload_test.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../people-service/test/peoplesort/upload_test.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad-date.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad-date.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/bad-date.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/bad-date.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/bad-header.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/bad-header.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/four-data.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/four-data.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/four-header.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/four-header.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/hashes.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/hashes.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/mixed.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/mixed.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/commas.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/commas.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/pipes-extra.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/pipes-extra.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/pipes.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/pipes.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/spaces.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/spaces.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/peoplecli/core.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/peoplecli/core.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/peoplecli/ingester.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/peoplecli/ingester.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/peoplecli/reporter.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/peoplecli/reporter.clj" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProjectId" id="1VIdkAtjwIc7tiU3OuE1D5H1TW7" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
    <option name="showMembers" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="cursive.last.file.extension./Users/kennethtilton/peoplesort/peoplecli/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/resources/bad" />
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
    <property name="show.migrate.to.gradle.popup" value="false" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/resources/bad" />
      <recent name="$PROJECT_DIR$/resources" />
    </key>
  </component>
  <component name="ReplState" timestamp="1577364278877">{:repl-history {:ide [], :local [{:command &quot;(def people-props-reqd\n  {:first  {}\n   :last   {}\n   :gender {:parser (fn [g] \n                      (or (some #{%} [\&quot;male\&quot; \&quot;female\&quot;])\n                        (throw (Exception. (str \&quot;Invalid gender: \&quot; g)))))}\n   :color  {}\n   :dob    {:parser    ing/dob-parse\n            :formatter rpt/dob-display}})&quot;, :offset 303, :ns &quot;peoplecli.core&quot;} {:command &quot;(def people-props-reqd\n  {:first  {}\n   :last   {}\n   :gender {:parser (fn [g] \n                      (or (some #{g} [\&quot;male\&quot; \&quot;female\&quot;])\n                        (throw (Exception. (str \&quot;Invalid gender: \&quot; g)))))}\n   :color  {}\n   :dob    {:parser    ing/dob-parse\n            :formatter rpt/dob-display}})&quot;, :offset 303, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn process-inputs\n  ([input-files]\n   (process-inputs input-files nil))\n\n  ([input-files reporter]\n   (let [input-specs (map #(people-file-validate people-props-reqd %) input-files)]\n     (when-not (some nil? input-specs)\n       (let [parsed-rows (distinct\n                           ;; ^^^ seems right\n                           (mapcat people-file-ingest input-specs))]\n         (when reporter\n           (reporter parsed-rows)))))))&quot;, :offset 438, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim prop-specs col-headers]\n                           :as   input-spec}]\n  (prn :pfi-specs prop-specs)\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     ;(prn :mapi row-no row)\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       ;(prn :rpa row-no cols)\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (into []\n                         (map (fn [col-value col-header]\n                                (let [col-spec (col-header prop-specs)]\n                                  ;(prn :hdr col-value col-header col-spec)\n                                  (when-let [p (:parser col-spec)]\n                                    (prn :p p))\n                                  (try\n                                    (or (:parser col-spec) col-value)\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           col-values col-headers))))\n        (line-seq rdr)))))&quot;, :offset 1463, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate {:first {}\n                          :last {}\n                          :gender {}\n                          :color {}}\n                         {:name   :dob\n                          :parser dob-parse}\n    \&quot;resources/spaces.csv\&quot;)&quot;, :offset 253, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn process-inputs\n  ([input-files]\n   (process-inputs input-files nil))\n\n  ([input-files reporter]\n   (let [input-specs (map #(people-file-validate people-props-reqd %) input-files)]\n     (when-not (some nil? input-specs)\n       (let [parsed-rows (distinct\n                           ;; ^^^ seems right behavior to de-dupe\n                           (mapcat people-file-ingest input-specs))]\n         (when reporter\n           (reporter parsed-rows)))))))&quot;, :offset 458, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(def people-props-reqd\n  {:first  {}\n   :last   {}\n   :gender {:parser (fn [g]\n                      (or (some #{g} [\&quot;male\&quot; \&quot;female\&quot;])\n                        (throw (Exception. (str \&quot;Invalid gender: \&quot; g)))))}\n   :color  {}\n   :dob    {:parser    dob-parse\n            :formatter dob-display}})&quot;, :offset 294, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate\n    people-props-reqd\n    \&quot;resources/spaces.csv\&quot;)&quot;, :offset 71, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn header-parse\n  [allowed-delims prop-specs header-string]\n  (some #(let [col-delim (re-pattern (str \&quot;\\\\\&quot; %))\n               col-headers (mapv (comp keyword str/trim)\n                             (str/split header-string col-delim))\n               headers-missing (set/difference\n                                 (set (keys prop-specs))\n                                 (set col-headers))]\n           (when (and (empty? headers-missing)\n                   ;; now that we support excess columns, testing the space\n                   ;; as a delimiter can be a mess if the header contains\n                   ;; multiple spaces or an unsupported delimiter such as #.\n                   (every? (fn [hdr] (re-matches #\&quot;[a-zA-Z0-9-_\\.]+\&quot;\n                                       (name hdr)))\n                     col-headers))\n             {:col-delim   col-delim\n              :col-headers col-headers}))\n    allowed-delims))&quot;, :offset 923, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(declare people-props-reqd)&quot;, :offset 27, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate people-props-reqd \&quot;resources/pipes.csv\&quot;)&quot;, :offset 62, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate people-props-reqd \&quot;resources/spaces.csv\&quot;)&quot;, :offset 63, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim prop-specs col-headers]\n                           :as   input-spec}]\n  (prn :pfi-specs prop-specs)\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     ;(prn :mapi row-no row)\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       ;(prn :rpa row-no cols)\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (into []\n                         (map (fn [col-value col-header]\n                                (let [col-spec (col-header prop-specs)]\n                                  ;(prn :hdr col-value col-header col-spec)\n                                  (try\n                                    ((or (:parser col-spec) identity) col-value)\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           col-values col-headers))))\n        (line-seq rdr)))))&quot;, :offset 1359, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-ingest\n     (people-file-validate\n       people-props-reqd\n       \&quot;resources/pipes.csv\&quot;))&quot;, :offset 102, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim prop-specs col-headers]\n                           :as   input-spec}]\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     ;(prn :mapi row-no row)\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       ;(prn :rpa row-no cols)\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (into []\n                         (map (fn [col-value col-header]\n                                (let [col-spec (col-header prop-specs)]\n                                  ;(prn :hdr col-value col-header col-spec)\n                                  (try\n                                    ((or (:parser col-spec) identity) col-value)\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           col-values col-headers))))\n        (rest (line-seq rdr))))))&quot;, :offset 1336, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-report [input-specs people-data]\n  (let [col-order [:last :first :dob :gender :color]]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (name col)))\n    (doseq [col col-order]\n      (pp/cl-format true\n        (:format-field (col input-specs))\n        (apply str (repeat (count (name col)) \&quot;-\&quot;)))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      (let [[last first gender color dob]\n            (map (fn [person-val formatter]\n                   (try\n                     ((or formatter identity) person-val)\n                     (catch Exception e\n                       \&quot;#####\&quot;)))\n              person-vals col-formatters)]\n        (pp/cl-format true \&quot;~&amp;~20a ~20a ~10a ~20a ~10a~%\&quot;\n          first last gender color dob)))))&quot;, :offset 1109, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(people-file-validate\n    people-props-reqd\n    \&quot;resources/pipes.csv\&quot;)&quot;, :offset 70, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate\n       people-props-reqd\n       \&quot;resources/spaces.csv\&quot;)&quot;, :offset 77, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-map (zipmap col-headers col-values)]\n                         (prn :colmap col-map)\n                        (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  ;(prn :hdr col-value col-header col-spec)\n                                  (try\n                                    ((or (:parser col-spec) identity) col-value)\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                            [:last :first :gender :color :dob]))))\n        (rest (line-seq rdr))))))&quot;, :offset 1329, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-values (zipmap col-headers col-values)]\n                         (prn :colmap col-map)\n                        (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  ;(prn :hdr col-value col-header col-spec)\n                                  (try\n                                    ((or (:parser col-spec) identity)\n                                     (col-header col-values))\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                            [:last :first :gender :color :dob]))))\n        (rest (line-seq rdr))))))&quot;, :offset 1383, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-values (zipmap col-headers col-values)]\n                         (prn :colmap col-values)\n                        (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  ;(prn :hdr col-value col-header col-spec)\n                                  (try\n                                    ((or (:parser col-spec) identity)\n                                     (col-header col-values))\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                            [:last :first :gender :color :dob]))))\n        (rest (line-seq rdr))))))&quot;, :offset 1386, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-ingest\n     (people-file-validate\n       people-props-reqd\n       \&quot;resources/spaces.csv\&quot;))&quot;, :offset 103, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-values (zipmap col-headers col-values)]\n                         (prn :cvals col-values)\n                         ;; parse each value while also standardizing column order\n                         (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  ;(prn :hdr col-value col-header col-spec)\n                                  (try\n                                    ((or (:parser col-spec) identity)\n                                     (col-header col-values))\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           [:last :first :gender :color :dob]))))\n        (rest (line-seq rdr))))))&quot;, :offset 1468, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn process-inputs\n  ([input-files]\n   (process-inputs input-files nil))\n\n  ([input-files reporter]\n   (let [input-specs (map #(people-input-analyze people-props-reqd %) input-files)]\n     (when-not (some nil? input-specs)\n       (let [parsed-rows (distinct\n                           ;; ^^^ seems right behavior to de-dupe\n                           (mapcat people-file-ingest input-specs))]\n         (prn :parsed parsed-rows)\n         (when reporter\n           (reporter input-specs parsed-rows)))))))&quot;, :offset 505, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(process-inputs [\&quot;resources/spaces.csv\&quot;] #(pp/pprint %2))&quot;, :offset 57, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(ns peoplecli.ingester\n  (:require [clojure.pprint :as pp]\n            [clojure.string :as str]\n            [clj-time.format :as tfm]\n            [clojure.java.io :as io]\n            [clojure.set :as set]\n            [peoplecli.reporter :as rpt]))&quot;, :offset 247, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-report [input-specs people-data]\n  (let [col-order [:last :first :dob :gender :color]]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (name col)))\n    (doseq [col col-order]\n      (pp/cl-format true\n        (:format-field (col input-specs))\n        (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      (let [[last first gender color dob]\n            (map (fn [person-val formatter]\n                   (try\n                     ((or formatter identity) person-val)\n                     (catch Exception e\n                       \&quot;#####\&quot;)))\n              person-vals col-formatters)]\n        (pp/cl-format true \&quot;~&amp;\&quot;)\n\n\n          first last gender color dob)))))&quot;, :offset 1085, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [input-specs people-data]\n  (let [col-order [:last :first :dob :gender :color]]\n    (doseq [[title comparator]\n            [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n             [\&quot;By DOB\&quot; comp-dob-asc]\n             [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n      (pp/cl-format true\n        \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (name col)))\n      (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n      #_ (doseq [person-vals (sort comparator people-data)]\n        (let [[last first gender color dob]\n              (map (fn [person-val formatter]\n                     (try\n                       ((or formatter identity) person-val)\n                       (catch Exception e\n                         \&quot;#####\&quot;)))\n                person-vals col-formatters)]\n          (pp/cl-format true \&quot;~&amp;\&quot;)\n\n\n          first last gender color dob)))))&quot;, :offset 1130, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [input-specs people-data]\n  (let [col-order [:last :first :dob :gender :color]]\n    (doseq [[title comparator]\n            [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n             [\&quot;By DOB\&quot; comp-dob-asc]\n             [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n      (pp/cl-format true\n        \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doseq [col col-order]\n        (prn :col col (name col)(col input-specs))\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (name col)))\n      (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n      #_ (doseq [person-vals (sort comparator people-data)]\n        (let [[last first gender color dob]\n              (map (fn [person-val formatter]\n                     (try\n                       ((or formatter identity) person-val)\n                       (catch Exception e\n                         \&quot;#####\&quot;)))\n                person-vals col-formatters)]\n          (pp/cl-format true \&quot;~&amp;\&quot;)\n\n\n          first last gender color dob)))))&quot;, :offset 1181, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [input-specs people-data]\n  (prn :inputs input-specs)\n  (let [col-order [:last :first :dob :gender :color]]\n    (doseq [[title comparator]\n            [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n             [\&quot;By DOB\&quot; comp-dob-asc]\n             [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n      (pp/cl-format true\n        \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doseq [col col-order]\n        (prn :col col (name col)(col input-specs))\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (name col)))\n      (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col input-specs))\n          (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n      #_ (doseq [person-vals (sort comparator people-data)]\n        (let [[last first gender color dob]\n              (map (fn [person-val formatter]\n                     (try\n                       ((or formatter identity) person-val)\n                       (catch Exception e\n                         \&quot;#####\&quot;)))\n                person-vals col-formatters)]\n          (pp/cl-format true \&quot;~&amp;\&quot;)\n\n\n          first last gender color dob)))))&quot;, :offset 1209, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn process-inputs\n  ([input-files]\n   (process-inputs input-files nil))\n\n  ([input-files reporter]\n   (let [input-specs (map #(people-input-analyze people-props-reqd %) input-files)]\n     (when-not (some nil? input-specs)\n       (let [parsed-rows (distinct\n                           ;; ^^^ seems right behavior to de-dupe\n                           (mapcat people-file-ingest input-specs))]\n         (prn :parsed parsed-rows)\n         (when reporter\n           (reporter people-props-reqd parsed-rows)))))))&quot;, :offset 511, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(def people-props-reqd\n  {:first  {:format-field \&quot;~20a\&quot;}\n   :last   {:format-field \&quot;~20a\&quot;}\n   :gender {:format-field \&quot;~10a\&quot;\n            :parser       (fn [g]\n                            (or (some #{g} [\&quot;male\&quot; \&quot;female\&quot;])\n                              (throw (Exception. (str \&quot;Invalid gender: \&quot; g)))))}\n   :color  {:format-field \&quot;~20a\&quot;}\n   :dob    {:format-field \&quot;~10a\&quot;\n            :parser       dob-parse\n            :formatter    dob-display}})&quot;, :offset 444, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-report [props-required people-data]\n  (prn :propsreqd props-required)\n  (let [col-order [:last :first :dob :gender :color]]\n    (doseq [[title comparator]\n            [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n             [\&quot;By DOB\&quot; comp-dob-asc]\n             [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n      (pp/cl-format true\n        \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doseq [col col-order]\n        (prn :col col (name col)(col props-required))\n        (pp/cl-format true\n          (:format-field (col props-required))\n          (name col)))\n      (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col props-required))\n          (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n      #_ (doseq [person-vals (sort comparator people-data)]\n        (let [[last first gender color dob]\n              (map (fn [person-val formatter]\n                     (try\n                       ((or formatter identity) person-val)\n                       (catch Exception e\n                         \&quot;#####\&quot;)))\n                person-vals col-formatters)]\n          (pp/cl-format true \&quot;~&amp;\&quot;)\n\n\n          first last gender color dob)))))&quot;, :offset 1227, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [props-required people-data]\n  (prn :propsreqd props-required)\n  (let [col-order [:last :first :dob :gender :color]]\n    (doseq [[title comparator]\n            [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n             [\&quot;By DOB\&quot; comp-dob-asc]\n             [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n      (pp/cl-format true\n        \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col props-required))\n          (name col)))\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doseq [col col-order]\n        (pp/cl-format true\n          (:format-field (col props-required))\n          (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n      #_ (doseq [person-vals (sort comparator people-data)]\n        (let [[last first gender color dob]\n              (map (fn [person-val formatter]\n                     (try\n                       ((or formatter identity) person-val)\n                       (catch Exception e\n                         \&quot;#####\&quot;)))\n                person-vals col-formatters)]\n          (pp/cl-format true \&quot;~&amp;\&quot;)\n\n\n          first last gender color dob)))))&quot;, :offset 1206, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(process-inputs [\&quot;resources/spaces.csv\&quot;] rpt/people-report)&quot;, :offset 59, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-report [prop-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (let [[last first gender color dob]\n            (map (fn [person-val formatter]\n                   (try\n                     ((or formatter identity) person-val)\n                     (catch Exception e\n                       \&quot;#####\&quot;)))\n              person-vals prop-specs)]\n        (pp/cl-format true \&quot;~&amp;~%\&quot;)\n        (doseq [spec prop-specs]\n          (pp/cl-format true\n            (:format-field spec)\n            (try\n              ((or (:formatter spec) identity) person-val)\n              (catch Exception e\n                \&quot;#####\&quot;))))\n        (pp/cl-format true \&quot;~&amp;~%\&quot;)\n\n\n        first last gender color dob))))&quot;, :offset 1457, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [prop-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (name col)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        prop-specs person-vals)\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1167, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [prop-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        prop-specs person-vals)\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1169, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [prop-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec prop-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        prop-specs person-vals)\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1170, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn -main [&amp; args]\n  #_;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what      :uncaught-exception\n                        :exception ex\n                        :where     (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n  (let [input (parse-opts args people-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [help]} options\n        filepaths arguments]\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    peoplesort options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      (empty? filepaths) (println \&quot;\\nNo data files provideed. Exiting.\\n\\n\&quot;)\n\n      (not-every? ing/file-found? filepaths) (do)\n\n      :default\n      (ing/process-inputs\n        filepaths\n        #_rpt/people-report\n        pp/pprint)\n\n      ;; WARNING: comment this out for use with REPL\n      #_(shutdown-agents))))&quot;, :offset 1079, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn -main [&amp; args]\n  #_;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what      :uncaught-exception\n                        :exception ex\n                        :where     (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n  (let [input (parse-opts args people-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [help]} options\n        filepaths arguments]\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    peoplesort options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      (empty? filepaths) (println \&quot;\\nNo data files provideed. Exiting.\\n\\n\&quot;)\n\n      (not-every? ing/file-found? filepaths) (do)\n\n      :default\n      (ing/process-inputs\n        filepaths\n        #_rpt/people-report\n        (fn [_ data] (pp/pprint data)))\n\n      ;; WARNING: comment this out for use with REPL\n      #_(shutdown-agents))))&quot;, :offset 1100, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn -main [&amp; args]\n  #_;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what      :uncaught-exception\n                        :exception ex\n                        :where     (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n  (let [input (parse-opts args people-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [help]} options\n        filepaths arguments]\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    peoplesort options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      (empty? filepaths) (println \&quot;\\nNo data files provideed. Exiting.\\n\\n\&quot;)\n\n      (not-every? ing/file-found? filepaths) (do)\n\n      :default\n      (ing/process-inputs\n        filepaths\n        rpt/people-report\n        #_ (fn [_ data] (pp/pprint data)))\n\n      ;; WARNING: comment this out for use with REPL\n      #_(shutdown-agents))))&quot;, :offset 1101, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn comp-dob-asc\n  [p1 p2]\n  (prn :p1 p1)(prn :p2 p2)\n  (tm/before? dob1 dob2))&quot;, :offset 81, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-dob-asc\n  [p1 p2]\n  (prn :p1 p1)(prn :p2 p2)\n  true #_\n  (tm/before? dob1 dob2))&quot;, :offset 91, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(-main \&quot;resources/pipes.csv\&quot; \&quot;resources/commas.csv\&quot;)&quot;, :offset 52, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn dob-parse [dob-in]\n  \&quot;Convert from YYYY-mm-dd to Date object\&quot;\n  (prn :parsing!!!!! dob-in)\n  (tfm/parse (tfm/formatter \&quot;yyyy-MM-dd\&quot;) dob-in))&quot;, :offset 147, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-values (zipmap col-headers col-values)]\n                         ;; parse each value while also standardizing column order\n                         ;; which we now allow to vary in input files\n                         (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  (prn :hdr col-value col-header col-spec)\n                                  (try\n                                    ((or (:parser col-spec) identity)\n                                     (col-header col-values))\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           people-col-order))))\n        (rest (line-seq rdr))))))&quot;, :offset 1470, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(def people-col-order [:last :first :dob :gender :color])&quot;, :offset 57, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-values (zipmap col-headers col-values)]\n                         ;; parse each value while also standardizing column order\n                         ;; which we now allow to vary in input files\n                         (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  (prn :hdr  col-header col-spec (col-header col-values))\n                                  (try\n                                    ((or (:parser col-spec) identity)\n                                     (col-header col-values))\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           people-col-order))))\n        (rest (line-seq rdr))))))&quot;, :offset 1485, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-input-analyze [prop-specs filepath]\n  (with-open [rdr (io/reader filepath)]\n    (when-let [header-def (header-parse \&quot;|, \&quot; prop-specs (first (line-seq rdr)))]\n      (prn :hdef header-def)\n      (merge header-def {:filepath   filepath\n                         :prop-specs prop-specs}))))&quot;, :offset 298, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-input-analyze people-props-reqd \&quot;resources/spaces.csv\&quot;)&quot;, :offset 63, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-ingest\n    (people-inut-analyze\n      people-props-reqd\n      \&quot;resources/spaces.csv\&quot;))&quot;, :offset 99, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (prn :specs col-specs)\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-values (zipmap col-headers col-values)]\n                         ;; parse each value while also standardizing column order\n                         ;; which we now allow to vary in input files\n                         (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  (prn :hdr  col-header col-spec (col-header col-values))\n                                  (try\n                                    ((or (:parser col-spec) identity)\n                                     (col-header col-values))\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           people-col-order))))\n        (rest (line-seq rdr))))))&quot;, :offset 1510, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [{:keys [filepath col-delim col-specs col-headers]\n                           :as   input-spec}]\n  (prn :specs input-spec)\n  (with-open [rdr (io/reader filepath)]\n    (into []                                                ;; trick to realize all before closinr reader\n      (map-indexed (fn [row-no row]\n                     (let [col-values (map str/trim (str/split row col-delim))]\n                       (when (&lt; (count col-values) (count col-headers))\n                         (throw (Exception. (str \&quot;Insufficient column count \&quot; (count col-values)\n                                              \&quot; at row \&quot; (inc row-no)\n                                              \&quot; in file \&quot; filepath))))\n                       (let [col-values (zipmap col-headers col-values)]\n                         ;; parse each value while also standardizing column order\n                         ;; which we now allow to vary in input files\n                         (map (fn [col-header]\n                                (let [col-spec (col-header col-specs)]\n                                  (prn :hdr  col-header col-spec (col-header col-values))\n                                  (try\n                                    ((or (:parser col-spec) identity)\n                                     (col-header col-values))\n                                    (catch Exception e\n                                      \&quot;#####\&quot;))))\n                           people-col-order))))\n        (rest (line-seq rdr))))))&quot;, :offset 1511, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-ingest\n    (people-input-analyze\n      people-props-reqd\n      \&quot;resources/spaces.csv\&quot;))&quot;, :offset 100, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [;[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals)\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1180, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-dob-asc\n  [p1 p2]\n  (tm/before? dob1 dob2))&quot;, :offset 54, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-dob-asc\n  [[_ _ dob1 _ _] [_ _ dob2 _ _]]\n  (tm/before? dob1 dob2))&quot;, :offset 78, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [;[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (prn :pvals person-vals)\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals)\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1211, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [;[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (prn :pvals person-vals)\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals))\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1219, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(def people-props-reqd\n  {:first  {:label \&quot;Given name\&quot;\n            :format-field \&quot;~20a\&quot;}\n   :last   {:label \&quot;Surname\&quot;:format-field \&quot;~20a\&quot;}\n   :gender {:label \&quot;Gender\&quot;\n            :format-field \&quot;~10a\&quot;\n            :parser       (fn [g]\n                            (or (some #{g} [\&quot;male\&quot; \&quot;female\&quot;])\n                              (throw (Exception. (str \&quot;Invalid gender: \&quot; g)))))}\n   :color  {:label \&quot;Favorite color\&quot;\n            :format-field \&quot;~15a\&quot;}\n   :dob    {:label \&quot;Born\&quot;\n            :format-field \&quot;~16a\&quot;\n            :parser       dob-parse\n            :formatter    dob-display}})&quot;, :offset 582, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [;[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~&amp;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals))\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1188, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [;[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~&amp; \&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals))\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1187, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [;[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals))\n      (pp/cl-format true \&quot;~%\&quot;))))&quot;, :offset 1186, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [;[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals)))\n    (pp/cl-format true \&quot;~%\&quot;)))&quot;, :offset 1184, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           ;[\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals)))\n    (pp/cl-format true \&quot;~%\&quot;)))&quot;, :offset 1183, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-females-first-then-last-asc\n  \&quot;a compare function sorting females first then by\n   ascending last name, case-insensitively\&quot;\n  [[l1 _ _ g1 _] [l2 _ _ g2 _]]\n  (cond\n    (= g1 \&quot;female\&quot;) (or (= g2 \&quot;male\&quot;)\n                      ;; both female, use last\n                      (compare (str/lower-case l1) (str/lower-case l2)))\n    :default\n    ;; g1 is male\n    (cond\n      (= g2 \&quot;female\&quot;) false\n      ;; both male, use last\n      :default (compare (str/lower-case l1) (str/lower-case l2)))))&quot;, :offset 498, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]\n           ]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    (doseq [person-vals (sort comparator people-data)]\n      ;;\n      ;; --- the people --------------------------------\n      ;;\n      (pp/cl-format true \&quot;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals)))\n    (pp/cl-format true \&quot;~%\&quot;)))&quot;, :offset 1182, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;)&quot;, :offset 30, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;\n    \&quot;resources/commas.csv\&quot;\n    \&quot;resources/commas.csv\&quot;)&quot;, :offset 84, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;\n    \&quot;resources/pipes.csv\&quot;\n    \&quot;resources/spacess.csv\&quot;)&quot;, :offset 84, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main ;;\&quot;resources/commas.csv\&quot;\n    ;;\&quot;resources/pipes.csv\&quot;\n    \&quot;resources/spaces.csv\&quot;)&quot;, :offset 87, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;\n    \&quot;resources/pipes.csv\&quot; \n    \&quot;resources/spaces.csv\&quot;)&quot;, :offset 84, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;\n    ;;\&quot;resources/pipes.csv\&quot;\n    \&quot;resources/spaces.csv\&quot;)&quot;, :offset 85, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn comp-dob-asc\n  [[_ _ dob1 _ _] [_ _ dob2 _ _]]\n  (prn :dobs dob1 dob2)\n  (tm/before? dob1 dob2))&quot;, :offset 102, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-dob-asc\n  [[_ _ dob1 _ _] [_ _ dob2 _ _]]\n  (prn :dob1 (type dob1) dob1)\n  (prn :dob2 (type dob2) dob2)\n  (tm/before? dob1 dob2))&quot;, :offset 140, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(dob-parse \&quot;2019-12-39\&quot;)&quot;, :offset 24, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(dob-parse \&quot;2019-12-30\&quot;)&quot;, :offset 24, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(type )&quot;, :offset 6} {:command &quot;(type (dob-parse \&quot;2019-12-30\&quot;))&quot;, :offset 31, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(= org.joda.time.DateTime (type (dob-parse \&quot;2019-12-30\&quot;)))&quot;, :offset 58, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(instance? (type (dob-parse \&quot;2019-12-30\&quot;))\n  org.joda.time.DateTime)&quot;, :offset 68, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(instance? org.joda.time.DateTime\n  (type (dob-parse \&quot;2019-12-30\&quot;))\n  )&quot;, :offset 71, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(instance? org.joda.time.DateTime\n  (dob-parse \&quot;2019-12-30\&quot;)\n  )&quot;, :offset 64, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(instance? org.joda.time.DateTime\n  (dob-parse \&quot;2019-12-302\&quot;)\n  )&quot;, :offset 65, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn date-time? [x]\n  (instance? org.joda.time.DateTime x))&quot;, :offset 60, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-dob-asc\n  [[_ _ dob1 _ _] [_ _ dob2 _ _]]\n  (if (date-time? dob1)\n    (if (date-time? dob2)\n      (tm/before? dob1 dob2))\n    (if (date-time? dob2)\n      false\n      true)))&quot;, :offset 184, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-dob-asc\n  [[_ _ dob1 _ _] [_ _ dob2 _ _]]\n  (if (date-time? dob1)\n    (if (date-time? dob2)\n      (tm/before? dob1 dob2)\n      true)\n    (if (date-time? dob2)\n      false\n      true)))&quot;, :offset 195, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn comp-dob-asc\n  \&quot;Comparator for ascending dates, dropping invalid dates to bottom\&quot;\n  [[_ _ dob1 _ _] [_ _ dob2 _ _]]\n  (if (date-time? dob1)\n    (if (date-time? dob2)\n      (tm/before? dob1 dob2)\n      true)\n    (if (date-time? dob2)\n      false\n      true)))&quot;, :offset 264, :ns &quot;peoplecli.reporter&quot;} {:command &quot;2&quot;, :offset 1, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(-main ;;\&quot;resources/commas.csv\&quot;\n    \&quot;resources/pipes.csv\&quot;\n    ;; \&quot;resources/spaces.csv\&quot;\n    )&quot;, :offset 93, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    ;;\n    ;; --- title and column headers --------------------------------\n    ;;\n    (pp/cl-format true\n      \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (:label spec)))\n\n    (pp/cl-format true \&quot;~&amp;~%\&quot;)\n    (doseq [spec col-specs]\n      (pp/cl-format true\n        (:format-field spec)\n        (apply str (repeat (count (:label spec)) \&quot;-\&quot;))))\n\n    ;;\n    ;; --- the people --------------------------------\n    ;;\n    (doseq [person-vals (sort comparator people-data)]\n      (pp/cl-format true \&quot;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals)))\n    (pp/cl-format true \&quot;~%\&quot;)))&quot;, :offset 1164, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report-header\n  \&quot;Output title and column headers\&quot;\n  [title col-specs]\n  \n  (pp/cl-format true\n    \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n  (pp/cl-format true \&quot;~&amp;~%\&quot;)\n  (doseq [spec col-specs]\n    (pp/cl-format true\n      (:format-field spec)\n      (:label spec)))\n\n  (pp/cl-format true \&quot;~&amp;~%\&quot;)\n  (doseq [spec col-specs]\n    (pp/cl-format true\n      (:format-field spec)\n      (apply str (repeat (count (:label spec)) \&quot;-\&quot;)))))&quot;, :offset 446, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn people-report [col-specs people-data]\n  (doseq [[title comparator]\n          [[\&quot;By Gender and Last Name\&quot; comp-females-first-then-last-asc]\n           [\&quot;By DOB\&quot; comp-dob-asc]\n           [\&quot;By Descending Last Name\&quot; comp-last-dsc]]]\n    (people-report-header title col-specs)\n    ;;\n    ;; --- the people --------------------------------\n    ;;\n    (doseq [person-vals (sort comparator people-data)]\n      (pp/cl-format true \&quot;~%\&quot;)\n      (doall (map (fn [spec val]\n             (pp/cl-format true\n               (:format-field spec)\n               (try\n                 ((or (:formatter spec) identity) val)\n                 (catch Exception e\n                   \&quot;#####\&quot;))))\n        col-specs person-vals)))\n    (pp/cl-format true \&quot;~%\&quot;)))&quot;, :offset 739, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(defn -main [&amp; args]\n  #_;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what      :uncaught-exception\n                        :exception ex\n                        :where     (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n  (let [input (parse-opts args people-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [help]} options\n        filepaths arguments]\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    peoplesort options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1)\n             \&quot;\\n\&quot;)\n\n      (empty? filepaths) (println \&quot;\\nNo data files provideed. Exiting.\\n\\n\&quot;)\n\n      (not-every? ing/file-found? filepaths) (do)\n\n      :default\n      (ing/process-inputs\n        filepaths\n        rpt/people-report\n        #_ (fn [_ data] (pp/pprint data)))\n\n      ;; WARNING: comment this out for use with REPL\n      #_(shutdown-agents))))&quot;, :offset 1119, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn -main [&amp; args]\n  #_;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what      :uncaught-exception\n                        :exception ex\n                        :where     (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n  (let [input (parse-opts args people-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [help]} options\n        filepaths arguments]\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n    peoplesort options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1)\n             \&quot;\\n\&quot;)\n\n      (empty? filepaths) (println \&quot;\\nNo data files provideed. Exiting.\\n\\n\&quot;)\n\n      (not-every? ing/file-found? filepaths) (do)\n\n      :default\n      (ing/process-inputs\n        filepaths\n        rpt/people-report\n        #_ (fn [_ data] (pp/pprint data)))\n\n      ;; WARNING: comment this out for use with REPL\n      #_(shutdown-agents))))&quot;, :offset 1117, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn people-report-header\n  \&quot;Output title and column headers\&quot;\n  [title col-specs]\n\n  (pp/cl-format true\n    \&quot;~&amp;~%~%~a~%------------------------~%\&quot; title)\n\n  (pp/cl-format true \&quot;~&amp;\&quot;)\n  (doseq [spec col-specs]\n    (pp/cl-format true\n      (:format-field spec)\n      (:label spec)))\n\n  (pp/cl-format true \&quot;~&amp;~%\&quot;)\n  (doseq [spec col-specs]\n    (pp/cl-format true\n      (:format-field spec)\n      (apply str (repeat (count (:label spec)) \&quot;-\&quot;)))))&quot;, :offset 442, :ns &quot;peoplecli.reporter&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;\n    \&quot;resources/pipes.csv\&quot;\n    \&quot;resources/spaces.csv\&quot;\n    )&quot;, :offset 88, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;-h\&quot;)&quot;, :offset 12, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;\n    \&quot;resources/pipes.csv\&quot;\n    \&quot;resources/spaces.csv\&quot;)&quot;, :offset 83, :ns &quot;peoplecli.core&quot;}], :remote []}}</component>
  <component name="RunManager">
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="NREPL" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="local" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="peoplecli" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
  </component>
  <component name="ServiceViewManager">
    <option name="viewStates">
      <list>
        <serviceView>
          <treeState>
            <expand />
            <select />
          </treeState>
        </serviceView>
      </list>
    </option>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="aef1bef0-1ae4-4a98-9cf4-dad6d86e150b" name="Default Changelist" comment="" />
      <created>1576944683124</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1576944683124</updated>
    </task>
    <servers />
  </component>
  <component name="WindowStateProjectService">
    <state x="2355" y="229" key="FileChooserDialogImpl" timestamp="1576962755993">
      <screen x="1680" y="23" width="1920" height="999" />
    </state>
    <state x="2355" y="229" key="FileChooserDialogImpl/1680.23.1920.999/0.23.1680.1027@1680.23.1920.999" timestamp="1576962755993" />
    <state x="1904" y="164" key="NewModule_or_Project.wizard" timestamp="1577134084816">
      <screen x="1680" y="23" width="1920" height="999" />
    </state>
    <state x="1904" y="164" key="NewModule_or_Project.wizard/1680.23.1920.999/0.23.1680.1027@1680.23.1920.999" timestamp="1577134084816" />
    <state x="2150" y="346" width="824" height="570" key="find.popup" timestamp="1577363584987">
      <screen x="1680" y="23" width="1920" height="1057" />
    </state>
    <state x="2150" y="346" width="824" height="570" key="find.popup/1680.23.1920.1057/0.23.1680.969@1680.23.1920.1057" timestamp="1577363584987" />
    <state x="2124" y="338" width="824" height="538" key="find.popup/1680.23.1920.999/0.23.1680.1027@1680.23.1920.999" timestamp="1577156349645" />
  </component>
</project>