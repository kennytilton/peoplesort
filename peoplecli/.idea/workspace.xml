<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="aef1bef0-1ae4-4a98-9cf4-dad6d86e150b" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/resources/bad/bad-header.csv" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/resources/pipes-extra.csv" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/peoplecli/ingester.clj" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/peoplecli/reporter.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/bad-date.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/bad-date.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/four-data.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/four-data.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/four-header.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/four-header.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/hashes.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/hashes.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/bad/mixed.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/bad/mixed.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/commas.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/commas.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/pipes.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/pipes.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/resources/spaces.csv" beforeDir="false" afterPath="$PROJECT_DIR$/resources/spaces.csv" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/peoplecli/core.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/peoplecli/core.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/default/classes/META-INF/maven/peoplecli/peoplecli/pom.properties" beforeDir="false" afterPath="$PROJECT_DIR$/target/default/classes/META-INF/maven/peoplecli/peoplecli/pom.properties" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/default/repl-port" beforeDir="false" afterPath="$PROJECT_DIR$/target/default/repl-port" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProjectId" id="1VIdkAtjwIc7tiU3OuE1D5H1TW7" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
    <option name="showMembers" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="cursive.last.file.extension./Users/kennethtilton/peoplesort/peoplecli/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/resources/bad" />
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
    <property name="show.migrate.to.gradle.popup" value="false" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/resources/bad" />
      <recent name="$PROJECT_DIR$/resources" />
    </key>
  </component>
  <component name="ReplState" timestamp="1577059869192">{:repl-history {:ide [], :local [{:command &quot;(-main \&quot;-oD\&quot; \&quot;pipesxxx.csv\&quot;)&quot;, :offset 28, :ns &quot;peoplecli.core&quot;} {:command &quot;(#\&quot;[aAdQ\&quot; \&quot;D\&quot;)&quot;, :offset 14, :ns &quot;peoplecli.core&quot;} {:command &quot;(#\&quot;[aAdQ]\&quot; \&quot;D\&quot;)&quot;, :offset 15, :ns &quot;peoplecli.core&quot;} {:command &quot;(some #\&quot;[aAdQ]\&quot; \&quot;D\&quot;)&quot;, :offset 20, :ns &quot;peoplecli.core&quot;} {:command &quot;(includes \&quot;aAdD\&quot; \&quot;x\&quot;)&quot;, :offset 21, :ns &quot;peoplecli.core&quot;} {:command &quot;(includes? \&quot;aAdD\&quot; \&quot;x\&quot;)&quot;, :offset 22, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/includes? \&quot;aAdD\&quot; \&quot;x\&quot;)&quot;, :offset 26, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/includes? \&quot;aAdD\&quot; \&quot;D\&quot;)&quot;, :offset 26, :ns &quot;peoplecli.core&quot;} {:command &quot;(def people-cli\n  [[\&quot;-s\&quot; \&quot;--sort SORTBY\&quot; \&quot;Sort by, default by last name.\&quot;\n    :default \&quot;n\&quot;\n    ;; :parse-fn #(Integer/parseInt %)\n    :validate [#(str/includes? \&quot;nNgGbB\&quot; %) \&quot;Sort code must be (case insensitively): 'n' for last name, 'g' for gender, or 'b' for birth date.\&quot;]]\n\n   [\&quot;-o\&quot; \&quot;--order ORDER\&quot; \&quot;[A]scending or [D]escending order.\&quot;\n    :default 80\n    ;;:parse-fn #(Integer/parseInt %)\n    :validate [#(str/includes? \&quot;aAdD\&quot; %)  \&quot;Must be A or D, case-insensitive, for ascending or descending sort.\&quot;]]\n\n   ;; A boolean option defaulting to nil\n   [\&quot;-h\&quot; \&quot;--help\&quot;]]\n  )&quot;, :offset 571, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn -main [&amp; args]\n  #_ ;; uncomment during development so errors get through when async in play\n  (Thread/setDefaultUncaughtExceptionHandler\n     (reify Thread$UncaughtExceptionHandler\n       (uncaughtException [_ thread ex]\n         (log/error {:what :uncaught-exception\n                     :exception ex\n                     :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n  (prn :argsin args)\n  (let [input (parse-opts args people-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [help sortby order]} options\n        filepaths arguments]\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    peoplesort options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      (empty? filepaths) (do)\n\n      (not-every? true? (map file-found? arguments)) (do)\n\n      :default\n      (println \&quot;RSN\&quot;))\n\n    ;; WARNING: comment this out for use with REPL\n    #_ (shutdown-agents)))&quot;, :offset 976, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;-sG\&quot;)&quot;, :offset 13, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;-sG\&quot; \&quot;pipesxx.csv\&quot;)&quot;, :offset 27, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;-sG\&quot; \&quot;pipes.csv\&quot;)&quot;, :offset 25, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;-sG\&quot; \&quot;resources/pipes.csv\&quot;)&quot;, :offset 35, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n  \n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header %)]\n           (when (= reqd-col-ct (count elts))\n             (map str/trim elts \&quot; \&quot;)))\n     allowed-delims))&quot;, :offset 379, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern %s))]\n           (when (= reqd-col-ct (count elts))\n             (map str/trim elts \&quot; \&quot;)))\n     allowed-delims))&quot;, :offset 391, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern %))]\n           (when (= reqd-col-ct (count elts))\n             (map str/trim elts \&quot; \&quot;)))\n     allowed-delims))&quot;, :offset 390, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern (str %)))]\n           (when (= reqd-col-ct (count elts))\n             (map str/trim elts \&quot; \&quot;)))\n     allowed-delims))&quot;, :offset 396, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern (str %)))]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             (map str/trim elts \&quot; \&quot;)))\n     allowed-delims))&quot;, :offset 424, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;one | two | three\&quot; (re-pattern \&quot;|\&quot;))&quot;, :offset 48, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;one | two | three\&quot; #\&quot;|\&quot;)&quot;, :offset 36, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;one | two | three\&quot; #\&quot;\\|\&quot;)&quot;, :offset 37, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;one | two | three\&quot; #\&quot;\\ \&quot;)&quot;, :offset 37, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern (str \&quot;\\\\\&quot; %)))]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             (map str/trim elts \&quot; \&quot;)))\n     allowed-delims))&quot;, :offset 429, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern (str \&quot;\\\\\&quot; %)))]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             (map #(str/trim % \&quot; \&quot;) elts)))\n     allowed-delims))&quot;, :offset 434, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern (str \&quot;\\\\\&quot; %)))]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             (map (fn [e] (str/trim e \&quot; \&quot;))\n               elts)))\n     allowed-delims))&quot;, :offset 457, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern (str \&quot;\\\\\&quot; %)))]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             (map str/trim elts)))\n     allowed-delims))&quot;, :offset 425, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return [delim elts], else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [elts (str/split header (re-pattern (str \&quot;\\\\\&quot; %)))]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             [% (map str/trim elts)]))\n     allowed-delims))&quot;, :offset 429, :ns &quot;peoplecli.core&quot;} {:command &quot;(header-parse \&quot;|, \&quot; 3 \&quot;one | two | three\&quot;)&quot;, :offset 42, :ns &quot;peoplecli.core&quot;} {:command &quot;(header-parse \&quot;|, \&quot; 4 \&quot;one | two | three\&quot;)&quot;, :offset 42, :ns &quot;peoplecli.core&quot;} {:command &quot;(header-parse \&quot;z, \&quot; 3 \&quot;one | two | three\&quot;)&quot;, :offset 42, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return a vector of the regex splitter pattern\n  that succeeded and the elements trimmed of whitespace, else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [splitter (re-pattern (str \&quot;\\\\\&quot; %))\n               elts (str/split header splitter)]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             [splitter (map str/trim elts)]))\n     allowed-delims))&quot;, :offset 551, :ns &quot;peoplecli.core&quot;} {:command &quot;(header-parse \&quot;,| \&quot; 5 \&quot; one| two | three| four | five\&quot;)&quot;, :offset 55, :ns &quot;peoplecli.core&quot;} {:command &quot;(list (header-parse \&quot;,| \&quot; 5 \&quot; one| two | three| four | five\&quot;)\n     (header-parse \&quot;,| \&quot; 5 \&quot; one two three four  five\&quot;))&quot;, :offset 118, :ns &quot;peoplecli.core&quot;} {:command &quot;(list (header-parse \&quot;,| \&quot; 5 \&quot; one| two | three| four | five\&quot;)\n     (header-parse \&quot;,| \&quot; 5 \&quot; one two three four five\&quot;))&quot;, :offset 117, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;a  b\&quot; #\&quot; \&quot;)&quot;, :offset 23, :ns &quot;peoplecli.core&quot;} {:command &quot;(list #_ (header-parse \&quot;,| \&quot; 5 \&quot; one| two | three| four | five\&quot;)\n     (header-parse \&quot;,| \&quot; 5 \&quot; one two three four five\&quot;))&quot;, :offset 120, :ns &quot;peoplecli.core&quot;} {:command &quot;(list #_ (header-parse \&quot;,| \&quot; 5 \&quot; one| two | three| four | five\&quot;)\n     (header-parse \&quot;,| \&quot; 5 \&quot;one two three four five\&quot;))&quot;, :offset 119, :ns &quot;peoplecli.core&quot;} {:command &quot;(set [ 1 2 3])&quot;, :offset 14, :ns &quot;peoplecli.core&quot;} {:command &quot;(set [ 1 2 3 2])&quot;, :offset 16, :ns &quot;peoplecli.core&quot;} {:command &quot;(ns peoplecli.core-test\n  (:require [clojure.test :refer :all]\n            [peoplecli.core :refer :all]))&quot;, :offset 105, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    (is (= [#\&quot;,\&quot; [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]]\n          (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)))))&quot;, :offset 181, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(vec (1 2 3))&quot;, :offset 13, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(vec (list 1 2 3))&quot;, :offset 18, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return a vector of the regex splitter pattern\n  that succeeded and the elements trimmed of whitespace, else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [splitter (re-pattern (str \&quot;\\\\\&quot; %))\n               elts (str/split header splitter)]\n           (prn :elts elts)\n           (when (= reqd-col-ct (count elts))\n             [splitter (mapv str/trim elts)]))\n     allowed-delims))&quot;, :offset 552, :ns &quot;peoplecli.core&quot;} {:command &quot;\&quot;\\|\&quot;&quot;, :offset 4, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(re-pattern \&quot;\\,\&quot;)&quot;, :offset 17, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    (is (= [(re-pattern \&quot;,\&quot;) [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]]\n          (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)))))&quot;, :offset 193, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(re-pattern \&quot;,\&quot;)&quot;, :offset 16, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    (is (= [(re-pattern \&quot;\\|\&quot;) [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]]\n          (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)))))&quot;, :offset 194, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    (prn :bam (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    #_ (is (= [(re-pattern \&quot;\\|\&quot;) [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]]\n          (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)))))&quot;, :offset 273, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    (prn :bam (header-parse \&quot;, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    #_ (is (= [(re-pattern \&quot;\\|\&quot;) [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]]\n          (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)))))&quot;, :offset 272, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(map str/trim [\&quot; 2 2\&quot;])&quot;, :offset 23, :ns &quot;peoplecli.core&quot;} {:command &quot;(mapv\n  str/trim [\&quot; 2 2\&quot;])&quot;, :offset 26, :ns &quot;peoplecli.core&quot;} {:command &quot;\&quot;\\a\&quot;&quot;, :offset 4, :ns &quot;peoplecli.core&quot;} {:command &quot;\&quot;\\\\a\&quot;&quot;, :offset 5, :ns &quot;peoplecli.core&quot;} {:command &quot;(re-pattern \&quot;|\&quot;)&quot;, :offset 16, :ns &quot;peoplecli.core&quot;} {:command &quot;(split \&quot;a|bc\&quot; )&quot;, :offset 14} {:command &quot;(str/split \&quot;a|b|c\&quot; (re-pattern \&quot;|\&quot;))&quot;, :offset 36, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;a|b|c\&quot; (re-pattern \&quot;\\|\&quot;))&quot;, :offset 37, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;a|b|c\&quot; (re-pattern \&quot;\\\\|\&quot;))&quot;, :offset 38, :ns &quot;peoplecli.core&quot;} {:command &quot;(header-parse \&quot;|\&quot; 2 \&quot;a|b\&quot;)&quot;, :offset 26, :ns &quot;peoplecli.core&quot;} {:command &quot;(prn :bam (header-parse \&quot;,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))&quot;, :offset 69, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(prn :bam (header-parse \&quot;|,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))&quot;, :offset 70, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    ;(prn :bam (header-parse \&quot;|,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    (is (= [(re-pattern \&quot;,\&quot;) [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]]\n          (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)))))&quot;, :offset 269, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(= [1 2][1 2])&quot;, :offset 14, :ns &quot;peoplecli.core&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    ;(prn :bam (header-parse \&quot;|,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    (is (= [(re-pattern \&quot;\\\\,\&quot;) [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]]\n          (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)))))&quot;, :offset 271, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid delim\&quot;\n    ;(prn :bam (header-parse \&quot;|,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    (let [[delim elts] (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)]\n      (is (= delim (re-pattern \&quot;\\\\,\&quot;)))\n      (is (= elts [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;])))))&quot;, :offset 312, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(= #\&quot;\\\\,\&quot; #\&quot;\\\\,\&quot;)&quot;, :offset 17, :ns &quot;peoplecli.core&quot;} {:command &quot;(str/split \&quot;a|c\&quot; (re-pattern \&quot;|\&quot;))&quot;, :offset 34, :ns &quot;peoplecli.core&quot;} {:command &quot;(deftest header\n  (testing \&quot;valid headers\&quot;\n    ;(prn :bam (header-parse \&quot;|,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    (let [[delim elts] (header-parse \&quot;|, \&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;)]\n      (is (= (str delim) (str (re-pattern \&quot;\\\\,\&quot;))))\n      (is (= elts [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;])))\n\n    (let [[delim elts] (header-parse \&quot;|, \&quot; 5 \&quot;Smith | Bob| male|green|05/03/2001\&quot;)]\n      (is (= (str delim) (str (re-pattern \&quot;\\\\|\&quot;))))\n      (is (= elts [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;])))\n\n    (let [[delim elts] (header-parse \&quot;|, \&quot; 5 \&quot;Smith Bob male green 05/03/2001\&quot;)]\n      (is (= (str delim) (str (re-pattern \&quot;\\\\ \&quot;))))\n      (is (= elts [\&quot;Smith\&quot;, \&quot;Bob\&quot;, \&quot;male\&quot;, \&quot;green\&quot;, \&quot;05/03/2001\&quot;]))))\n\n  (testing \&quot;invalid delim\&quot;\n    ;(prn :bam (header-parse \&quot;|,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    (let [parse (header-parse \&quot;|# \&quot; 5 \&quot;Smith,Bob,male,green,05/03/2001\&quot;)]\n      (is (nil? parse))))\n\n  (testing \&quot;invalid count\&quot;\n    ;(prn :bam (header-parse \&quot;|,\&quot; 5 \&quot;Smith, Bob, male, green, 05/03/2001\&quot;))\n    (let [parse (header-parse \&quot;|, \&quot; 4 \&quot;Smith,Bob,male,green,05/03/2001\&quot;)]\n      (is (nil? parse)))))&quot;, :offset 1143, :ns &quot;peoplecli.core-test&quot;} {:command &quot;(every? even? [2 4])&quot;, :offset 20, :ns &quot;peoplecli.core&quot;} {:command &quot;(input-validate \&quot;resources/xpipes.csv\&quot;)&quot;, :offset 39, :ns &quot;peoplecli.core&quot;} {:command &quot;(file-found? \&quot;resources/xpipes.csv\&quot;)&quot;, :offset 36, :ns &quot;peoplecli.core&quot;} {:command &quot;(file-found? \&quot;resources/pipes.csv\&quot;)&quot;, :offset 35, :ns &quot;peoplecli.core&quot;} {:command &quot;(input-validate \&quot;resources/piesx.cxv\&quot;)&quot;, :offset 38, :ns &quot;peoplecli.core&quot;} {:command &quot;(input-validate \&quot;resources/pipes.cxv\&quot;)&quot;, :offset 38, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn input-validate [filepath]\n  (when (file-found? filepath)\n    (header-parse \&quot;, \&quot; 5\n      (with-open [rdr (clojure.java.io/reader filepath)]\n        (first (line-seq rdr))))))&quot;, :offset 179, :ns &quot;peoplecli.core&quot;} {:command &quot;(input-validate \&quot;resources/pipes.csv\&quot;)&quot;, :offset 38, :ns &quot;peoplecli.core&quot;} {:command &quot;(defn input-validate [filepath]\n  (when (file-found? filepath)\n    (header-parse \&quot;|, \&quot; 5\n      (with-open [rdr (clojure.java.io/reader filepath)]\n        (first (line-seq rdr))))))&quot;, :offset 180, :ns &quot;peoplecli.core&quot;} {:command &quot;(every? true [1 nil 2])&quot;, :offset 23, :ns &quot;peoplecli.core&quot;} {:command &quot;(every? true?\n  [1 nil 2])&quot;, :offset 26, :ns &quot;peoplecli.core&quot;} {:command &quot;(Date. \&quot;07-25-1951\&quot;)&quot;, :offset 20, :ns &quot;peoplecli.core&quot;} {:command &quot;(ns peoplecli.core\n  (:require [clojure.tools.cli :refer [parse-opts]]\n            [clojure.java.io :as io]\n            [taoensso.timbre :as log]\n            [clojure.core.async\n             :refer [go go-loop chan &gt;! &lt;! &lt;!! &gt;!! close!]\n             :as async]\n            [clojure.string :as str]\n            [clojure.pprint :as pp]\n            [clj-time.core :as tm]\n            [clj-time.format :as tfm])\n  (:gen-class))&quot;, :offset 423, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;resources/pipes.csv\&quot;)&quot;, :offset 29, :ns &quot;peoplecli.core&quot;} {:command &quot;(empty? #{})&quot;, :offset 12, :ns &quot;peoplecli.core&quot;} {:command &quot;(-main \&quot;resources/commas.csv\&quot;)&quot;, :offset 30, :ns &quot;peoplecli.core&quot;} {:command &quot;(people-file-validate \&quot;resources/pipes.csv\&quot;)&quot;, :offset 44, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn header-parse\n  \&quot;Try to parse string 'header' as a CSV row\n  with one of the 'allowed-delims' and check\n  that 'req-col-ct' elements are found.\n\n  If OK, return a vector of the regex splitter pattern\n  that succeeded and the elements trimmed of whitespace, else nil.\&quot;\n  [allowed-delims reqd-col-ct header]\n  (some #(let [splitter (re-pattern (str \&quot;\\\\\&quot; %))\n               elts (str/split header splitter)]\n           (prn :sp splitter elts (count elts))\n           (when (= reqd-col-ct (count elts))\n             [splitter (mapv str/trim elts)]))\n    allowed-delims))&quot;, :offset 571, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate \&quot;resources/spaces.csv\&quot;)&quot;, :offset 45, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate \&quot;resources/commas.csv\&quot;)&quot;, :offset 45, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(when-let [[a b] [1 2]] a)&quot;, :offset 26, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(when-let [[a b] nil] a)&quot;, :offset 24, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate \&quot;resources/bad/bad-date.csv\&quot;)&quot;, :offset 51, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-validate [props-reqd filepath]\n  (with-open [rdr (clojure.java.io/reader filepath)]\n    (when-let [[splitter col-headers] (header-parse \&quot;|, \&quot; 5 (first (line-seq rdr)))]\n      (let [headers-missing (set/difference (set col-headers) props-reqd)]\n        (cond\n          (empty? headers-missing)\n          {:splitter splitter\n           :headers  (map keyword col-headers)}\n          :default (do (println \&quot;Headers missing:\&quot; headers-missing)))))))&quot;, :offset 462, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-validate [props-reqd filepath]\n  (with-open [rdr (io/reader filepath)]\n    (when-let [[splitter col-headers] (header-parse \&quot;|, \&quot; 5 (first (line-seq rdr)))]\n      (let [headers-missing (clojure.set/difference (set col-headers) props-reqd)]\n        (cond\n          (empty? headers-missing)\n          {:splitter splitter\n           :headers  (map keyword col-headers)}\n          :default (do (println \&quot;Headers missing:\&quot; headers-missing)))))))&quot;, :offset 457, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(people-file-validate \&quot;resources/bad/bad-header.csv\&quot;)&quot;, :offset 53, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(ns peoplecli.ingester\n  (:require [clojure.pprint :as pp]\n            [clojure.string :as str]\n            [clj-time.format :as tfm]\n            [clojure.java.io :as io]\n            [clojure.set :as set]))&quot;, :offset 206, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-ingest [converters filepath [splitter _]]\n  ;(prn :cvs (count converters) :pfi filepath splitter)\n  (with-open [rdr (io/reader filepath)]\n    (into []\n      ;; realize all before closing reader\n      (map-indexed (fn [row-no row]\n                     ;(prn :mapi row-no row)\n                     (let [cols (map str/trim (str/split row splitter))]\n                       ;(prn :rpa row-no cols)\n                       (when (not= (count cols) (count converters))\n                         (throw (Exception. (str \&quot;Invalid column count at row \&quot;\n                                              (inc row-no) \&quot; in file \&quot; filepath))))\n                       (into []\n                         (map (fn [col converter]\n                                (try\n                                  ((or converter identity) col)\n                                  (catch Exception e\n                                    \&quot;#####\&quot;)))\n                           cols converters))))\n        (line-seq rdr)))))&quot;, :offset 1001, :ns &quot;peoplecli.ingester&quot;} {:command &quot;(defn people-file-validate [props-reqd filepath]\n  (with-open [rdr (io/reader filepath)]\n    (when-let [[splitter col-headers] (header-parse \&quot;|, \&quot; 5 (first (line-seq rdr)))]\n      (let [headers-missing (set/difference (set col-headers) props-reqd)]\n        (cond\n          (empty? headers-missing)\n          {:splitter splitter\n           :headers  (map keyword col-headers)}\n          :default (do (println \&quot;Headers missing:\&quot; headers-missing)))))))&quot;, :offset 449, :ns &quot;peoplecli.ingester&quot;}], :remote []}}</component>
  <component name="RunManager">
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="NREPL" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="local" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="peoplecli" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
  </component>
  <component name="ServiceViewManager">
    <option name="viewStates">
      <list>
        <serviceView>
          <treeState>
            <expand />
            <select />
          </treeState>
        </serviceView>
      </list>
    </option>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="aef1bef0-1ae4-4a98-9cf4-dad6d86e150b" name="Default Changelist" comment="" />
      <created>1576944683124</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1576944683124</updated>
    </task>
    <servers />
  </component>
  <component name="WindowStateProjectService">
    <state x="2355" y="229" key="FileChooserDialogImpl" timestamp="1576962755993">
      <screen x="1680" y="23" width="1920" height="999" />
    </state>
    <state x="2355" y="229" key="FileChooserDialogImpl/1680.23.1920.999/0.23.1680.1027@1680.23.1920.999" timestamp="1576962755993" />
    <state x="2124" y="338" width="824" height="538" key="find.popup" timestamp="1577037844242">
      <screen x="1680" y="23" width="1920" height="999" />
    </state>
    <state x="2124" y="338" width="824" height="538" key="find.popup/1680.23.1920.999/0.23.1680.1027@1680.23.1920.999" timestamp="1577037844242" />
  </component>
</project>